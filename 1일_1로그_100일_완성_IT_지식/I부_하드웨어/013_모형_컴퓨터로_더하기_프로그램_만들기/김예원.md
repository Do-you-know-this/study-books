# 1부. 하드웨어

## 013. 모형 컴퓨터로 더하기 프로그램 만들기

- 상상의 컴퓨터
  - 이론상의 설계를 **모방하여 작동하는(sinulate)** 프로그램을 만들 수 있어 상상의 컴퓨터를 위한 프로그램을 작성하고 어떻게 실행되는지 볼 수 있음
  - 이를 모형 컴퓨터(Toy computer)라 명명하겠음
  - 1960년대 말에 사용되던 미니컴퓨터(minicomputer) 정도의 수준이며, 벅스, 골드스타인, 폰 노이만의 논문에 제시된 설계와 어느 정도 비슷함
  - 구성 요소
    - 메모리
      - 명령어와 데이터를 저장하기 위한 공간
    - 누산기
      - 한 개의 수를 담을 만한 용량의 부가적인 저장 영역
      - -> 계산기에서 사용자가 가장 최근에 입력한 수나 가장 최근의 계산 결과를 담고 있는 디스플레이와 유사함
    - 명령어 레퍼토리
      - 기본 연산을 수행하기 위한 약 10개의 명령어 레퍼토리
      
      1. `GET` -> 키보드에서 수를 입력받은 후 누산기에 넣음(누산기의 기존 내용 덮어씀)
      2. `PRINT` -> 누산기의 내용을 출력함(누산기의 내용 변하지 않음)
      3. `STORE M` -> 누산기 내용의 복사본을 메모리 위치 M에 저장함(누산기의 내용 변하지 않음)
      4. `LOAD M` -> 메모리 위치 M의 내용을 누산지에 적재함(M의 내용 변하지 않음)
      5. `ADD M` -> 메모리 위치 M의 내용을 누산기의 내용에 더함(M의 내용 변하지 않음)
      6. `STOP` -> 실행을 중지함
  - 프로세서는 작동을 시작하면 첫 번재 메모리 위치에서 시작해서 다음과 같이 단순한 사이클을 반복한다.
    1. 인출(Fetch): 메모리에서 다음 명령어를 가져옴
    2. 해석(Decode): 명령어가 무슨 일을 하는지 알아냄
    3. 실행(Execute): 명령어를 실행함
    4. 인출 단계로 되돌아감

### 첫 번째 모형 프로그램

- 모형 컴퓨터를 위한 프로그램을 만들려면 원하는 작업을 수행할 일련의 명령어를 작성하고 메모리에 넣은 후, 프로세서에 그 명령어들을 실행하라고 지시해야 한다.
- 명령어들은 메모리에 이진수로 저장될 것이다.

메모리가 담고 있는 명령어

```
GET
PRINT
STOP
```

1. 사용자에게 수를 입력하도록 요청함
2. 그 수를 출력함
3. 프로세서에 중지하라고 명령함

### 두 번째 모형 프로그램

- 프로세서는 프로그램의 처음부터 시작해서 명령어를 한 번에 한 개씩 가져온다. 그러면서 각 명령어를 차례차례 실행하고 다음 명령어로 넘어간다.
- 주석(comment): 프로그래머에게 도움을 주는 해설 자료로, 주석은 프로그램 자체에는 아무 영향도 미치지 않는다.
- 아래 프로그램의 단 한 가지 까다로운 부분은 메모리에 데이터 값, 즉 나중에 사용할 첫 번재 수를 담을 공간을 확보해야 한다는 점이다.
  - 두 번째 `GET` 명령어를 실행하면 값을 덮어 써야 하므로 누산기에 첫 번째 수를 그대로 둘 수 없다. 그 값은 명령어가 아닌 데이터이므로 명령어로 해석되지 않을 메모리 공간 어딘가에 저장해 두어야 한다.
  - 데이터 값을 모든 명령어 다음에 오도록 프로그램의 끝에 두면 프로세서는 절대로 데이터 값을 명령어로 해석하려고 시도하지 않는다. 거기에 도달하기 전에 `STOP`할 것이기 때문이다.
  - 또한 프로그램의 명령어가 메모리 위치를 필요로 할 때, 그 위치를 나타낼 방법이 있어야 한다. 한 가지 방법은 명령어가 있는 메모리 위치 다음에 특정 위치를 지정하는 것으로, 이렇게 하면 `STORE 7`이라고 쓸 수 있다.
  - 위의 방법은 프로그램이 수정되고 데이터 위치가 바뀌었을 때 문제가 발생할 수 잇으므로 고정된 번호를 사용하는 것은 바람직하지 않다.
  - 해결책은 데이터 위치에 이름을 부여하는 것이다. ex) `FirstNum`
  - 데이터 위치의 이름은 임의로 정할 수 있지만, 목적이나 의미를 내포하도록 짓는 것이 좋은 습관이다.
  - 데이터 위치 이름 뒤에는 콜론을 붙여서 레이블임을 나타낸다.

메모리가 담고 있는 명령어

```
GET
STORE FirstNum
GET
ADD FirstNum
PRINT
STOP
```

1. 첫 번째 수를 입력받아 누산기에 넣는다.
2. FirstNum이라는 메모리 위치에 첫 번째 수를 저장한다.
3. 두 번째 수를 입력받아 누산기에 넣는다.
4. 첫 번째 수를 누산기에 있는 값에 더한다.
5. 결과 합계 값을 출력한다.
6. 프로그램 실행을 중지한다.

### 분기 명령어

- 두 번째 모형 프로그램을 확장해서 100개, 1000개의 수를 더하도록 하려면 어떻게 해야 할까?
  - 해결책은 프로세서의 명령어 레퍼토리에 일련의 명령어를 재사용하게 하는 새로운 종류의 명령어를 추가하는 것이다.
  - 종종 분기/점프라고 불리는 `GOTO` 명령어는 바로 다음 명령어가 아니라 `GOTO`가 지정하는 위치로 이동하여 명령어를 실행하도록 프로세서에 지시한다.
  - `GOTO` 명령어를 사용하면 프로세서가 프로그램의 앞부분으로 돌아가서 명령어 처리를 반복하도록 할 수 있다.
  - ex) 어떤 수가 입력될 때마다 출력해주는 프로그램
- 아래의 첫 번째 명령어에 `Top`이라는 레이블을 지정했는데, 이는 그 역할을 암시하기 위해 임의로 붙인 이름이다.
- 아래의 마지막 명령어는 프로세서가 첫 번째 명령어로 돌아가게 한다.

```
Top: GET
     PRINT
     GOTO Top
```

- 위 프로그램으로는 명령어를 재사용할 수는 있지만, 아직 루프(loop)가 무한정 계속되는 것을 멈출 방법이 없다.
  - 루프를 멈추려면 또 다른 종류의 명령어가 필요한데, 명령어를 무작정 계속 실행하도록 하지 않고 조건을 검사하여 다음에 수행할 작업을 결정하는 이 명령어를 조건부 분기(conditional branch)/조건부 점프(conditional jump)라고 한다.
  - 모형 컴퓨터의 `IFZERO` 명령어: 누산기의 값이 0이면 특정 명령어로 분기하고, 그렇지 않으면 바로 다음 명령어부터 실행을 계속함
  - `IFZERO` 다음에는 명령어가 아닌 메모리 위치가 와야 하므로 그렇게 하면 자동하지 않는다.

```
Top: GET
     IFZERO Bot
     PRINT
     GOTO Top
Bot: STOP
```

1. 수를 입력받아 누산기에 넣는다.
2. 누산기 값이 0이면 Bot 레이블(맨 끝, bottom을 의미)이 붙은 명령어로 이동한다.
3. 누산기 값이 0이 아니므로 그 값을 출력한다.
4. Top으로 돌아가서 다른 수를 입력받는다.

```
Top: GET
     IFZERO Bot
     ADD Sum
     STORE Sum
     GOTO Top
Bot: LOAD Sum
     PRINT
     STOP
Sum: 0
```

- Top
  1. 수를 입력받는다.
  2. 입력된 수가 0이면 Bot으로 간다.
  3. 가장 최근의 값에 누적 합계를 더한다.
  4. 결과를 새로운 누적 합계로 저장한다.
  5. Top으로 돌아가서 다른 수를 입력받는다.
- Bot
  1. 누적 합계를 누산기에 적재한다.
  2. 출력한다.
  3. 프로그램을 멈춘다.
- Sum: 누적 합계를 담을 메모리 위치(프로그램이 시작할 때 0으로 초기화됨)

- 테스트의 핵심은 '체계적으로' 하는 것이다. 그냥 무작위 입력을 프로그램에 던져주는 것은 효과적이지 않다.
  - 입력: 0
  - 입력: 1, 2 -> 출력: 3
  - ...

### 메모리 내부 표현

- 각 명령어가 각자의 숫자형 코드를 저장하는 데 메모리 위치를 한 개 사용하며, 명령어가 메모리를 참조하거나 데이터 값을 사용하면 바로 다음 위치도 사용한다고 가정하자.
  - 즉 `GET`은 메모리 위치를 한 개 사용하지만, 다른 메모리 위치도 참조하는 `IFZERO`와 `ADD`같은 명령어는 메모리 두 칸을 차지하고, 두 번재 칸은 참조하는 위치에 해당한다.
- 어떤 데이터 값이든 한 개의 메모리 위치에 들어간다고 가정하자.
- 다음 명령어의 숫자 값이 1부터 시작해서 1씩 증가하는 값이라고 가정하자. -> `GET = 1, PRINT = 2, STORE = 3, LOAD = 4, ADD = 5, STOP = 6, GOTO = 7, IFZERO = 8`
