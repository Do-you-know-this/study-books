# 2부. 소프트웨어

## 021. 검색을 쉽게 만드는 정렬

- 이진 검색을 사용하기 위한 예비 단계: 이름을 알파벳순으로 정렬하기
- 정렬(sorting)
  - 핵심적인 알고리즘 문제
  - 선택 정렬(selection sort)
    - 아직 정렬되지 않은 항목 중에서 다음 이름을 계속 선택하는 방법
    - 예시
      - Intel (7)
      - Facebook (4)
      - Zillow (16)
      - Yahoo (15)
      - Pinterest (10)
      - Twitter (13)
      - Verizon (14)
      - Bing (2)
      - Apple (1)
      - Google (5)
      - Microsoft (8)
      - Sony (12)
      - PayPal (9)
      - Skype (11)
      - IBM (6)
      - Ebay (3)
    - 정렬에 필요한 연산 횟수는 원래 항목의 수에 정비례한다. 하지만 훑어볼 때마다 항목의 수가 한 개씩 줄어들기 때문에 일반적으로 필요한 일의 양은 다음과 같이 계산된다
      - `N + (N - 1) + (N - 2) + (N + 3) + ... + 2 + 1`
      - 이 수열의 합계는 `N x (N + 1) / 2`이 되고, 풀어서 계산하면 `N의 제곱 / 2 + N / 2`이 된다. 2로 나누는 걸 무시하면 일의 양은 `N의 제곱 + N`에 비례한다.
      - N의 제곱은 금방 N보다 훨씬 큰 값이 되므로, 결과적으로 일의 양은 N의 제곱에 거의 비례하게 되는데, 이러한 증가율을 2차(quadratic)라고 한다. 2차는 선형보다 효율이 훨씬 더 낮다. 만약 정렬할 항목의 수가 2배가 되면 4배의 시간이 걸릴 것이고, 10배라면 100배의 시간이 걸릴 것이다.
  - 퀵 정렬(quick sort)
    - 분할 정복의 훌륭한 사례
    - 정렬되지 않은 상태에서 첫 글자가 A에서 M까지인 이름을 가진 그룹으로 모으고, N에서 Z까지인 이름을 가진 다른 그룹으로 모은다.
      - 이렇게 하면 그룹이 두 개 생기고, 각각에 절반 정도의 이름이 들어가 있다.
      - 여기서는 각 단계에서 양쪽 그룹에 이름의 절반 정도씩 들어갈 정도로 분포가 고르다고 가정한다.
      - 이제 A-M 그룹을 훑어보면서 A부터 F까지를 하나로, G부터 M까지를 하나로 모은다.
      - 그리고 N-Z 그룹을 훑어보면서 N부터 S까지를 하나로, T부터 Z까지를 하나로 보은다.
      - 이 시점까지 이름 전체를 두 번 훑어보았고, 네 개의 그룹으로 나누었으며, 각각의 이름은 전체 이름의 1/4 정도를 담고 있다.
      - 이를 다시 여덟 개의 그룹으로 분리한다.
      - 퀵 정렬에 필요한 연산의 양
        - 단계마다 16개의 이름 각각을 확인했다. 만일 매번 이름들이 딱 떨어지게 나뉘었다면 각 그룹에는 8개, 4개, 2개, 1개의 이름이 담길 것이다.
        - 단계의 수는 16이 1이 될 때까지 2로 나누는 횟수다. 이 값은 밑수 2에 대한 16의 로그로, 4가 된다.
        - 따라서 일의 양은 16개의 이름에 대해서 `16 log2 16` 다. 만일 데이터 전체를 네 번 훑어본다면 연산이 64번 일어나는 것이고, 이는 선택 정렬에서 연산이 136번 일어나는 것보다 현저히 적다.
      - 그룹을 나눈ㄹ 때마다 거의 같은 크기의 덩어리로 나눠야만 효율적이다.
      - 일반적인 퀵 정렬로 N개 항목을 정렬하려면 약 `N log N`번의 연산이 필요하다.
      - 작업의 양은 `N x log N` 에 비례한다. 선형보다는 약간 효율이 낮지만 N이 크다면 2차(N의 제곱)보다 훨씬 효율적이다.
