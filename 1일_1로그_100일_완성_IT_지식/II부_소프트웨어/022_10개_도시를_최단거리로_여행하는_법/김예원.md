# 2부. 소프트웨어

## 22. 10개 도시를 최단거리를 여행하는 법

- 알고리즘 복잡도(complexity) / 실행 시간의 스펙트럼
- 효율이 높은 알고리즘
  - 이진 검색(복잡도 `log N`)
  - 선형(복잡도 `N`, 가장 일반적인 경우)
  - 퀵 정렬(복잡도 `N log N`)
  - 선택 정렬(복잡도 `N의 제곱`)
  - ... (다른 복잡도 개념은 너무 심오해서 전문가들만 관심을 가지는 정도)
- 지수(exponential) 복잡도
  - 실생활에서 자주 등장하지만 효율이 특히 낮고 중요하기 때문
  - `2의 N승`
  - 일의 양이 유난히 빠르게 늘어남
    - 한 개의 항목을 추가하면 수행해야 할 일의 양이 두 배가 됨
  - 사실상 모든 가능한 경우를 하나씩 시도해 봐야만 하는 상황에서 발생
  - 몇몇 알고리즘, 특히 암호 기법에 사용되는 알고리즘은 특정 계산 과제를 수행하는 일이 지수 복잡도를 갖도록 하는 데 기반을 둠
    - 문제를 바로 푸는 일이 계산상 실행 불가능할 정도로 큰 N을 선택하여 적의 공격을 방지함
- 어떤 문제는 처리하기 쉽지만, 다른 문제는 더 어려워 보인다
  - 쉬운 문제
    - 복잡도 면에서 다항 ex) 실행 시간이 N의 제곱
    - 지수가 2보다 크면 적용하기 어려울 수도 있음
    - 이러한 부류의 문제를 다항을 의미하는 `P`(Polynomial)라고 부름
      - 다향 시간 내에 해결할 수 있기 때문
  - 실제로 발생하는 많은 문제나 그런 문제들의 근본이 되는 문제
    - 지수 알고리즘
    - 즉, 우리가 아는 다항 알고리즘으로는 풀 수 없음
    - `NP`(Nondeterministic Polynomial, 비결정적 다항) 문제
    - 해결책을 빨리 찾을 수는 없지만, 어떤 해결책을 알고 있다면 그것이 맞는지는 빨리 입증할 수 있음
    - -> 결정을 내려야 할 때 항상 옳게 추측하는 알고리즘이 있다면 NP 문제가 그 알고리즘에 의해 다항 시간 내에 해결될 수 있다는 뜻
      - 현실에서는 항상 올바른 선택을 하는 경우는 거의 없으므로 이는 단지 이론적인 개념
- 여행하는 외판원 문제(traveling salesman problem)
  - NP 문제
  - 외판원은 자신이 사는 도시에서 출발해 어떤 순서로든 다른 도시ㅏ를 모두 방문하고 나서 다시 출발점으로 돌아와야 한다.
  - 각 도시를 정확히 한 번씩(반복 없이) 방문하고, 전체 여행한 거리를 최소로 만드는 것이 목표다.
  - 최근접 이웃 휴리스틱 해법
    - 한 도시에서 시작해서 매번 아직 방문하지 않은 도시 중 가장 가까운 도시로 이동하는 방식
    - 시작하는 도시가 바뀌면 여행 경로가 바뀔 수 있다는 점에 주의해야 함
  - 최상의 해법
    - 경로 전체를 완전 탐색해서 찾아낸 최단 경로
    - 가장 짧은 최근접 이웃 경로보다 약 8퍼센트 짧음
  - 다른 다양한 문제도 이와 마찬가지로, 가능한 모든 해법을 완전 탐색하는 것보다 더 효율적으로 풀 방법이 없음
