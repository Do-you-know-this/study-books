# 2부. 소프트웨어

## 035. 운영체제가 일하는 법

1. 프로세서는 컴퓨터가 켜졌을 때 영구 기억 장치에 저장된 약간의 명령어를 실행해서 작동을 시작하도록 구성되어 있음
2. 이 명령어로 작은 플래시 메모리에서 명령어를 읽음. 여기에는 디스크상의 알려진 위치, USB 메모리, 또는 네트워크 연결에서 더 많은 명령어를 읽는 코드가 포함돼 있음
3. 플래시 메모리에서 읽은 명령어는 최종적으로 유용한 작업을 하기에 충분한 코드가 로드될 때까지 더욱더 많은 명령어를 읽음

- 이렇게 컴퓨터가 작동을 시작하는 과정을 부트스트래핑(bootstraping)이라고 불렀는데, 지금은 부팅(booting)이라고만 함
- 프로세서마다 세부 사항은 다르지만 기본 아이디어는 같음
- 부팅 과정
  - 메모리와 다른 구성 요소를 점검해서 올바르게 작동하는지 확인하는 절차 포함
  - 컴퓨터에 어떤 외부 장치가 연결되어 있는지 알아내고자 하드웨어에 질문하기도 함
  - 연결된 장치를 운영체제가 사용할 수 있도록 관련된 소프트웨어 구성 요소(드라이버)를 로드할 수 있음
- 부팅 이후
  - 운영체제는 일단 실행되면 꽤 간단한 작업 사이클을 집중적으로 수행하며, 실행할 준비가 됐거나 관심이 필요한 각 애플리케이션에 차례로 통제권을 줌
  - 운영체제는 프로세서가 프로세스(애플리케이션) 각각에 차례로 관심을 갖고 처리하게 하고, 필요에 따라 프로세스 간에 초점을 전환함
  - 각 프로그램은 짧은 시간 조각(time slice)을 할당받고 이 시간 조각은 프로그램이 시스템 서비스를 요청하거나 프로그램에 할당된 시간이 다 되면 끝남
  - 운영체제는 이벤트에 반응함 ex) 음악이 끝에 도달함, 메일을 받음, 웹페이지를 다운로드함, 키가 눌림
  - 운영체제는 각 이벤트에 대해 필요한 일을 수행하며, 보통은 그런 이벤트가 발생했다는 사실을 해당 이벤트를 처리해야 하는 애플리케이션에 전달함
  - 애플리케이션을 종료하면 운영체제는 프로그램이 사용하던 모든 자원을 회수하고, 화면에 창이 노출될 다른 애플리케이션에 창을 다시 그려야 한다고 알려줌
- 시스템 콜(system call)
  - 운영체제는 하드웨어와 다른 소프트웨어 간의 인터페이스를 제공함
  - 운영체제는 하드웨어가 실제보다 상위 레벨의 서비스를 제공하는 것처럼 보이게 함으로써 프로그래밍을 더 쉽게 할 수 있게 함
    - -> "운영체제는 애플리케이션이 구축될 수 있는 플랫폼(platform)을 제공함"
    - 추상화의 예시
      - 구현상 들쑥날쑥한 부분이나 관련 없는 세부 사항을 감추는 인터페이스 또는 외관을 제공함
  - 운영체제는 애플리케이션에 제공하는 작업이나 서비스의 집합을 정의함
    - 운영체제는 이러한 서비스를 표준화된 방식 또는 합의된 방식으로 이용할 수 있게 하고, 애플리케이션은 운영체제의 특정 부분에 통제권을 넘겨주는 특별한 명령어를 실행함으로써 서비스를 요청함
    - 운영체제는 요청에 포함된 일을 처리하고 통제권과 처리 결과를 애플리케이션에게 돌려줌
    - 운영체제에 서비스를 요청하는 이 진입점을 시스템 콜이라 함
    - 시스템 콜의 세부 명세에서 그 운영체제가 무엇인지를 규정함
    - 최신 운영체제에는 보통 수백 개의 시스템 콜이 있음
- 디바이스 드라이버(device driver)
  - 운영체제와 특정 하드웨어 장치 간에 가교 역할을 하는 코드
  - 드라이버 코드는 어떤 장치가 어떤 일을 하도록 하는 방법을 자세히 알고 있음
    - ex) 마우스나 트랙패드에서 오는 움직임과 버튼 정보를 이용하는 방법
  - 특정 장치의 특이한 속성에서 시스템의 나머지 부분을 분리함
    - ex) 키보드처럼 종류는 다양하지만 동일한 역할을 하는 장치
      - -> 드라이버 인터페이스는 운영체제가 서로 다른 장치에 균일한 방식으로 접근하도록 해서 장치를 전환하기 쉽게 해줌
      - -> 키보드마다 지원하는 기능에 차이가 있으므로 특정 키보드용 드라이버는 운영체제의 요청을 해당 프린터가 그 일을 수행하는 데 적합한 형태로 변환함
  - 범용 운영체제에는 많은 디바이스 드라이버가 있음
    - ex) 윈도우는 소비자들이 사용할 가능성이 있는 매우 다양한 장치를 위한 드라이버를 이미 설치한 상태로 출하함
    - ex) 모든 장치 제조사는 새로 나왔거나 업데이트된 드라이버를 다운로드할 수 있도록 웹사이트를 관리함
    - 부팅 시에는 시스템에 현재 가용 장치에 필요한 드라이버를 불러오는 작업도 이루어짐
  - 보통은 운영체제가 새로운 드라이버를 찾을 필요가 없음
    - 이 메커니즘이 너무나 표준화 되어 있어서 운영체제는 이미 필요한 것을 갖추고 있고, 장치를 구동하기 위한 세부 사항은 장치 내부의 프로세서에 내장되어 있기 때문
- 다양한 디지털 장치와 운영체제
  - 기술 발달 덕분에 장치들은 전반적으로 앞에서 살펴봤던 범용 컴퓨터와 비슷한 모습을 띠고 있음
  - 성능 좋은 프로세서 + 용량 큰 메모리 + 카메라 렌즈와 디스플레이 같은 주변 장치 여러개 + 정교한 UI + 네트워크 연결 + ...
  - 이런 추세가 계속되며 별도의 운영체제를 만들기보다는 범용 운영체제를 사용하는 방식이 더 타당함
  - 사용 환경이 특수한 경우가 아니라면 자신만의 전용 시스템을 개발하거나 값비싼 상용 제품의 라이선스를 얻는 것보다는 리눅스에서 불필요한 부분을 뺀 버전을 사용하는 편이 더 쉽고 저렴함
    - 리눅스의 장점: 견고하고, 개조하기 용이하고, 이식 가능하고, 무료임
    - 리눅스의 단점: GPL 같은 라이선스에 따라 결과물 코드 일부를 공개해야 될 수도 있음
      - -> 장치에 포함된 지적 재산권의 보호에 관한 논쟁을 불러일으킬 수 있음 ex) 킨들, 티보
